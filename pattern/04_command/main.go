package main

import "fmt"

/*
	Реализовать паттерн «комманда».
	Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Command_pattern

	Command — это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

	Применимость:

	1. Отделение отправителя от получателя: Command позволяет отделить объект, инициирующий запрос ( отправитель ) от объекта, который фактически выполняет операцию ( получатель ). Это поддерживает более слабую связь между компонентами системы.
	2. Поддержка отмены операций: Посредством сохранения состояния и реализации метода отмены, Command может поддерживать отмену выполненных операций.
	3. Поддержка повторения операций: Совместно с отменой, паттерн также может обеспечивать возможность повторения отменённых операций.
	4. Построение очереди и логгирование: Command могут использоваться для построения очереди запросов, а также для регистрации операций для последующего анализа или отладки.

	Плюсы:

	1. Отделение отправителя от получателя: Уменьшает связанность между объектами системы, что облегчает расширение и изменение функциональности.
	2. Поддержка отмены и повторения операций: Позволяет создавать системы, поддерживающие отмену и повторение операций.
	3. Управление очередью операций: Позволяет построить систему с очередью Command для управления последовательностью операций.
	4. Легкость добавления новых команд: Новые Command могут быть добавлены без изменения существующего кода отправителя.

	Минусы:

	1. Увеличение числа классов: Каждая Command требует создания нового класса, что может привести к увеличению числа классов в системе.
	2. Сложность отслеживания изменений: Если объекты, участвующие в выполнении Command, часто изменяют свои состояния, может возникнуть сложность в управлении этими изменениями.
*/

// Command

type CommandInterface interface {
	Execute()
}

type Command struct {
	receiver ReceiverInterface
}

var _ CommandInterface = (*Command)(nil)

func (c *Command) Execute() {
	c.receiver.Action()
}

// Receiver

type ReceiverInterface interface {
	Action()
}

type Receiver struct{}

var _ ReceiverInterface = (*Receiver)(nil)

func (r *Receiver) Action() {
	fmt.Printf("action\n")
}

// Invoker

type Invoker struct {
	command CommandInterface
}

func (i *Invoker) SetCommand(command CommandInterface) {
	i.command = command
}

func (i *Invoker) ExecuteCommand() {
	i.command.Execute()
}

func main() {
	receiver := &Receiver{}
	command := &Command{receiver: receiver}
	invoker := &Invoker{}

	invoker.SetCommand(command)
	invoker.ExecuteCommand()
}
