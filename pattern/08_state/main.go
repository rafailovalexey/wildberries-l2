package main

import (
	"log"
)

/*
	Реализовать паттерн «состояние».
	Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/State_pattern

	State — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта.

	Применимость:

	1. Объект имеет большое количество состояний и переходы между ними часто изменяются.
	2. Поведение объекта зависит от его состояния, и это поведение изменяется динамически во время выполнения.

	Плюсы:

	1. Четкость структуры: State позволяет разделить состояния объекта на отдельные классы, что делает структуру кода более четкой и поддерживаемой.
	2. Легкость добавления новых состояний: Добавление новых состояний или изменение существующих становится более гибким и не требует изменения кода самого объекта.
	3. Избавление от больших условных конструкций: State помогает избежать больших блоков условий, в которых объект переключает свое поведение в зависимости от состояния.

	Минусы:

	1. Увеличение числа классов: State может привести к увеличению числа классов, что может быть избыточным в некоторых случаях.
	2. Сложность в поддержке: В случае небольших и статичных состояний в объекте, использование паттерна может усложнить код без значительной выгоды.
*/

type StateInterface interface {
	handle() string
}

type Context struct {
	state StateInterface
}

func (c *Context) SetState(state StateInterface) {
	c.state = state
}

func (c *Context) Request() string {
	return c.state.handle()
}

type StateA struct{}

var _ StateInterface = (*StateA)(nil)

func (s *StateA) handle() string {
	return "State A"
}

type StateB struct{}

var _ StateInterface = (*StateB)(nil)

func (s *StateB) handle() string {
	return "State B"
}

func main() {
	context := &Context{state: &StateA{}}
	log.Printf("%v\n", context.Request())

	context.SetState(&StateB{})
	log.Printf("%v\n", context.Request())
}
