package main

import "fmt"

/*
	Реализовать паттерн «фасад».
	Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Facade_pattern

	Facade (фасад) — это структурный шаблон проектирования, который обеспечивает упрощенный (но ограниченный) интерфейс для сложной системы классов. Вместо того, чтобы заставлять ваш код напрямую работать с десятками классов платформы, вы создаете фасадный класс, который инкапсулирует эту функциональность и скрывает ее от остального кода.

	Применимость:

	1. Сложные подсистемы: Когда существует сложная система или набор взаимосвязанных классов, и вы хотите предоставить более простой интерфейс для взаимодействия с этой системой.
	2. Снижение зависимостей: Когда вы хотите уменьшить зависимость клиентского кода от внутренней структуры подсистемы, делая систему более гибкой к изменениям.
	3. Улучшение читаемости: Когда необходимо улучшить читаемость и понимание кода, скрывая детали реализации сложных операций.

	Плюсы:

	1. Упрощение интерфейса: Фасад предоставляет простой интерфейс для взаимодействия с комплексной системой, что упрощает использование этой системы.
	2. Снижение зависимостей: Фасад позволяет уменьшить зависимость клиентского кода от внутренних деталей системы, что делает код более гибким и менее подверженным изменениям.
	3. Повышение уровня абстракции: Фасад повышает уровень абстракции, скрывая сложность системы и предоставляя более высокоуровневый интерфейс.

	Минусы:

	1. Ограниченность функциональности: Фасад может предоставлять только ограниченный набор функциональности системы. Если клиентскому коду потребуется более сложная операция, ему придется обращаться к низкоуровневым компонентам напрямую.
	2. Дублирование функциональности: В некоторых случаях фасад может дублировать функциональность, которая уже предоставляется низкоуровневыми компонентами, что может привести к избыточности кода.
*/

type SubsystemA struct{}

func (s *SubsystemA) OperationA1() {
	fmt.Printf("%s\n", "SubsystemA: OperationA1")
}

func (s *SubsystemA) OperationA2() {
	fmt.Printf("%s\n", "SubsystemA: OperationA2")
}

type SubsystemB struct{}

func (s *SubsystemB) OperationB1() {
	fmt.Printf("%s\n", "SubsystemB: OperationB1")
}

func (s *SubsystemB) OperationB2() {
	fmt.Printf("%s\n", "SubsystemB: OperationB2")
}

type Facade struct {
	subsystemA *SubsystemA
	subsystemB *SubsystemB
}

func NewFacade() *Facade {
	return &Facade{
		subsystemA: &SubsystemA{},
		subsystemB: &SubsystemB{},
	}
}

func (f *Facade) Operation() {
	f.subsystemA.OperationA1()
	f.subsystemA.OperationA2()

	f.subsystemB.OperationB1()
	f.subsystemB.OperationB2()
}

func main() {
	facade := NewFacade()

	facade.Operation()
}
